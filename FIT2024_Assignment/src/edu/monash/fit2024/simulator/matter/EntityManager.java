package edu.monash.fit2024.simulator.matter;
/**
 * EntityManager: stores an association between Entities and their Locations.
 * 
 * Generated by UML Lab
 * 
 * @author ram
 * @date 17 February 2013
 */

/*
 * Changelog
 * 
 * 2013-03-04: made generic (ram)
 * 2013-03-08: made to depend on EntityInterface instead of Entity (ram)
 * 2013-04-09: added remove method (ram)
 * 2017-01-20: Extended the java doc for content method and added comments
 */

import java.util.ArrayList;
import java.util.List;

import edu.monash.fit2024.simulator.space.Direction;
import edu.monash.fit2024.simulator.space.Location;
import edu.monash.fit2024.simulator.util.BiMultiMap;

public class EntityManager<E extends EntityInterface, L extends Location> {
	private BiMultiMap<E, L> storage;
	
	/**
	 * Constructor for the Entity Manager. Initializes a Multi Bit Map for storage of entities on the map
	 */
	public EntityManager() {
		storage = new BiMultiMap<E, L>();
	}
	
	/**
	 * <p>Returns the Location of an entity, or null if that entity is not found.</p>
	 * 
	 * @author ram
	 * @param e the entity to search for
	 * @return the Location of e, or null if e is not found
	 */
	public L whereIs(E e) {
		return storage.get(e);
	}
	
	/**
	 * <p>Removes an entity from the map.</p>
	 * 
	 * @author ram
	 * @param e the entity to remove
	 */
	public void remove(EntityInterface e) {
		storage.remove(e);
	}
	
	/**
	 * <p>Returns a List containing all Entities in the target location,
	 * and an empty list if no such location is found or if there are no Entities in that location.</p>
	 * 
	 * @author ram
	 * @param loc Location to search for
	 * @return list of all Entities in loc
	 */
	public List<E> contents(final L loc) {
		return storage.reverseLookup(loc);
		
	}
	
	/**
	 * <p>Sets the location of entity e to location loc.  This will remove the
	 * entity from its original location.</p>
	 * 
	 * @param e the Entity to move
	 * @param loc the destination location
	 */
	public void setLocation(E e, L loc) {
		storage.put(e, loc);
	}
	

	/**
	 * <p>Allow time to pass.</p>
	 * 
	 * <p>Tells each entity in the world to update itself and/or schedule an action.</p>
	 */
	public void tick() {
		
		//loop through all the Entities in the world
		for (E e: storage.keySet()) {
			e.tick(storage.get(e));
		}
	}
	
	/**
	 * <p>Returns true if and only if the specified entity is in a location that has a neighboring location in the specified direction.</p>
	 * 
	 * @author ram
	 * @param d Direction to check for exit
	 * @param e Entity in question
	 * @return true if and only if e can see an exit in direction d
	 */
	
	public boolean seesExit(E e, Direction d) {
		return whereIs(e).hasExit(d);
	}
	
	/**
	 * <p>Returns a list of actions available to the given Actor.  This includes Actions intrinsic to the Actor
	 * as well as Affordances belonging to other Entities in the same location.  No checking is done as to
	 * whether the Actor can actually perform the actions.</p>
	 * 
	 * @author ram
	 * @param a actor 
	 * @return List<Action> of possible actions
	 * 
	 * @modified dsquire 20130416
	 *  - added check so that the actor's own affordances aren't added to this list of things it can do.
	 *    Affordances are things that can be done *to* an entity, not by it.
	 */
	/*
	 * This code has a couple of unchecked casts.  They can't be checked because
	 * generics are involved.
	 */
	@SuppressWarnings("unchecked")
	public <A extends ActionInterface> List<A> getActionsFor(Actor<A> a) {
		ArrayList<A> theActions = new ArrayList<A>();
		
		for (A ac: a.getActions()) {
			theActions.add(ac);
		}
		

		L loc = whereIs((E) a);
		for (E e: contents(loc)) {
			if (e != a) { // don't add the affordances if they belong to the actor itself
				for (Affordance aff: e.getAffordances()) {
					theActions.add((A) aff);
				}
			}
		}
		
		
		return theActions;
	}
}
