package edu.monash.fit2024.simulator.matter;

/**
 * Base class for Actors, i.e. entities that can perform commands.
 * 
 * Generated by UML Lab.
 * 
 * @author ram
 * @date 17 February 2013
 */

/*
 * Changelog
 * 
 * 2013-02-28: Added perform() method (ram)
 * 2013-03-01: Made generic to avoid downcasts in client code (ram)
 * 	Made actions protected so that it can be instantiated in client code (ram)
 * 2013-03-04: Took out genericity because it was getting excessive (ram)
 * 	And then put it back in. (ram)
 * 2013-03-07: added MessageRenderer to constructor to accommodate change in Entity (ram)
 * 2013-04-07: fixed up generics and made getActions return an ArrayList instead of an Array.
 * 2017-01-20	:added a not about == and isEquals in the comments
 */

import java.util.ArrayList;
import java.util.Set;

import edu.monash.fit2024.simulator.space.Location;
import edu.monash.fit2024.simulator.time.Scheduler;
import edu.monash.fit2024.simulator.userInterface.MessageRenderer;

public abstract class Actor<T extends ActionInterface> extends Entity {

	protected static Scheduler s;
	
	/**A set of actions that can be performed by the <code>Actor</code>*/
	protected Set<T> actions;
	
	/**The amount of time an <code>Actor</code> has to wait before it could <code>act</code>*/
	private int waittime;
	
	/**
	 * <p>Register a new Action as part of this actor's command set.  This does nothing if the Action
	 * is already registered, although note that it is possible to add two identically-constructed Actions
	 * to the command set if they are not the same object, i.e. the comparison is done with == rather than
	 * isEqual.</p>
	 * 
	 *
	 * @param a the Action to add
	 */
	public void addAction(T a) {
		actions.add(a);
	}
	
	
	/**
	 * Remove an Action from this actor's set of potential commands.  This does nothing if the
	 * Action was not in that set.
	 * 
	 * @param a the Action to remove
	 */
	public void removeAction(T a) {
		actions.remove(a);
	}
	
	/**
	 * The default constructor in the parent class (Entity) is private, so we have to pass the
	 * super constructor a parameter.
	 * 
	 * @param m a MessageRenderer that will allow the Actor to communicate
	 */
	public Actor(MessageRenderer m) {
		super(m);
		waittime =0;
	}
	
	/**
	 * <p>Returns an ArrayList containing references to all the Actions this actor can currently
	 * perform.  Does not include Affordances in objects in the same location; ask the EntityManager
	 * about those.</p>
	 * 
	 * @return an ArrayList containing this Actor's Actions
	 */
	public ArrayList<T> getActions() {
		ArrayList<T> newActions = new ArrayList<T>();
		for (T action: actions)
			newActions.add(action);
		return newActions;
	}
	
	/**
	 * Allows an actor act. This method will only be called if the actor is not waiting.
	 */
	public abstract void act();
	

	/**
	 * Tick method for the actor. Allows the actor to act if it's not waiting
	 * 
	 * @param l is the current location of the actor.
	 */
	public void tick(Location l) {
		
		if (waittime >0){//waiting since the wait time is greater than zero
			waittime --;
			this.setWaittime(waittime); //update the new waiting time
		}
		else{
			//perform action if not waiting
			act();
		}
	}
	
	/**
	 * Setter for the wait time
	 * @param waittime @see {@link #waittime}
	 */
	public void setWaittime(int waittime){
		this.waittime = waittime;
	}

	
	/**
	 * Getter for the wait time
	 * @return @see {@link #waittime}
	 */
	public int getWaittime() {
		return waittime;
	}
	

}

